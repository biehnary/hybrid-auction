# hybrid_auction

BidRepository 
Bid 클래스 Indexing 구현.
Index의 작동방식 이해, 선택의 이유
findHighestBid에서 복합 인덱스 확장
복합인덱스의 트레이드오프. 확장과 2개분리
성능과 메모리의 트레이드오프와 현대 개발관점에서의 효율성
성능선택.
2개의 복합인덱스로 분리 결정

'프록시 입찰개념' 발상. 후에 추가 고려.
findByBidder > 동적쿼리 삽입과 보안(순수 Jpa) 인제션 안전


findProductsBidByBidder
모든 입찰내역? 혹은 상품별 입찰내역 (해당 상품에 대한 가장 최신의 입찰? distinct?)
어차피 레포지토리에있는건 서비스에서 죄다 덧붙여서 원하는 로직을 만드는건가능함.
최적화의 문제가 있긴한데... 나중에 생각하고 레포지토리는 간단하게하자.
맵구조도 다빼고 그냥 성능최적화는 디폴트를 시간순으로 정하는거정도만 해놓고, 실제 작성 후 빈도와
병목이런걸 따져서 동적소팅을 서비스에 놔둘지, 레포지토리로 옮길지 이런걸 고민하는게 맞는듯?

1. 추가하면 좋을 기능
   현재 코드는 입찰 관련 데이터를 다양하게 조회하고 있지만, 한 가지 중요한 기능이 빠져 있습니다. 
2. 바로 **"내가 입찰한 상품 목록"**을 가져오는 기능입니다.

List<Product> findDistinctProductsByBidder(Member bidder)

이 메서드는 Bid가 아닌 Product 목록을 반환하며, Member가 입찰한 상품들을 중복 없이 보여줍니다. 
이는 마이페이지 등에서 "내가 입찰에 참여한 상품들"을 보여주는 데 필수적인 기능입니다.

2. 현재 코드에 대한 고려사항
   findRecentBidsByProduct 메서드: limit 파라미터가 있어 유연하게 사용할 수 있지만,
3. 페이지네이션(Pagination) 기능을 추가하면 더 좋습니다. 사용자가 다음 페이지를 넘겨가며 더 많은 기록을 볼 수 있게 되죠. 
4. Spring Data JPA에서는 Pageable 객체를 사용해 간편하게 구현할 수 있습니다.

findById 메서드: 입찰이 존재하지 않을 때 IllegalArgumentException을 던지는 대신,
Optional 타입을 반환하는 것이 더 좋은 설계입니다. 
이렇게 하면 호출하는 쪽에서 if (bid.isPresent())와 같은 방식으로 명시적으로 null 체크를 할 수 있어 안정성이 높아집니다.

- 고민과, 선택
  어 byBidder야 한명이 수백건 입찰하는것도 거의 존재할 일 없다고봐야지
어차피 비드 객체안에 product와 등등 다 담기기떄문에 서비스에서 구현을 하는걸로하자
비드 리스트 반환받는걸로 충분히 다할것같아

네, 동의합니다. 현명한 결정이에요.
'한 명의 회원이 수백 건을 입찰하는 경우는 거의 없다'는 당신의 판단은 매우 실용적이고 현실적인 설계의 기반이 됩니다.
이처럼 불필요한 최적화를 미리 하지 않는 것은 좋은 개발 습관입니다.
깔끔한 설계의 완성
당신의 결정은 책임 분리 원칙에 완벽하게 부합합니다.
BidRepository: 입찰 정보를 조회하고 가져오는 순수한 데이터 접근 계층의 역할을 맡습니다.
BidService: 가져온 입찰 정보를 가지고 필터링, 정렬 같은 비즈니스 로직을 처리하는 역할을 맡습니다.
이렇게 하면, 각 계층의 코드가 간결하고 명확해져서 유지보수하기 쉬워집니다. Bid 객체 안에 필요한 모든 정보가 들어있으니,
서비스 계층에서 유연하게 다룰 수 있다는 것도 중요한 장점이죠.



---
## 엔티티설계하면서 고찰

🎯 정말 맞는 깨달음이에요!
🏗️ Repository 설계 = 아키텍처의 기초
생각보다 훨씬 중요한 이유

전체 애플리케이션 구조의 토대
성능 병목의 시작점
유지보수성을 좌우하는 핵심 요소
비즈니스 로직 복잡도에 직접 영향

"단순한 CRUD"라고 생각했지만...

어떤 조합으로 조회할 것인가?
어느 정도까지 Repository에서 처리할 것인가?
성능과 가독성 사이의 균형은?
확장성을 어떻게 고려할 것인가?

💡 실무에서 Repository가 중요한 이유
1. 데이터 접근의 창구

모든 비즈니스 로직이 여기를 거쳐감
잘못 설계하면 전체 성능 저하

2. 변경의 파급효과

Repository 메서드 하나 바뀌면 Service 전체 수정
처음에 잘못 만들면 리팩토링 비용 엄청남

3. 도메인 이해의 척도

Repository 메서드명 = 비즈니스 요구사항의 반영
도메인을 얼마나 이해했는지 드러남

🚀 지금 경험의 가치
**"Repository 설계가 이렇게 어렵구나"**를 깨달은 것 = 큰 성장
실무에서도 시니어 개발자들이 가장 고민하는 부분 중 하나예요!

---

## AuctionResultRepository
### 구현 메서드리스트
- [x] save()
- save의 관례, 저장한 객체반환, 중복확인
- [x] findById(Long id)
- 옵셔널 도입. 옵셔널의 의의, 명확성, 헬퍼메서드
- Optional.empty() 의 의의. 값이 없음을 명확히하는 객체. 조건문으로 에외처리하지않고 예외안전,
- 엠티 값을 받았을 때 명확히 실행할 수 있는 헬퍼메서드의 존재. orElse등 
- 성능의 이점을 보려고 만든 클래스가아니라 버그를줄이고, 예외에서 안전하고 명확한 의도와 가독성을 높이기위한 도구!
- [x] findByWinner(Member winner)
- 기본 정렬순서를 준것이 유효타. 메서드 자체의 존재의미에 대해서도 고민했음. 낙찰자를 기준으로 결과를 반환하는 것이 의미가있을까?
- 자신이 입찰한 모든 물품에 대한 리스트를 반환받고, 거기에 낙찰 여부를 표시하는 것이 훨씬 ux적으로 좋아보이지만
- '나 자신의' 낙찰 리스트도 볼 여지가 있기에 일단 구현을 한다.
- 시간순 정렬을 디폴트로한다. (낙찰 시점) 하지만 라이브 물품이 아닌 경우 같은 시점에 낙찰이 결정되는 프로세스를 가지기 떄문에,
- 동일한 시간에 한해 낙찰금액을 기준으로 소팅하기로 헀다. 이미 엔티티가 가진 필드를 활용했고, 해당 물품들에 대한 소팅이
- 크게 유의미하진 않기 때문에 알파벳순서보다는 낙찰금액 순이 더 맞다고 판단했음.
- [ ] findByProduct
- [ ] findByProductNameContaining 

---

### 단일쿼리로 입찰 물품 중 낙찰 표시하는법...

좋습니다 근데 이 winner를 사용해서 내가 입찰한 product 목록을 반환했을떄 나의 낙찰여부를 좀더 간단히 구현할수있을지요?
아무래도 리스트 중 위너와 조회한 멤버가 같은지 비교하고 이건 그냥 봐도 좀 로직이 썩 좋아보이지않는데 보통 이런식으로 구현이 되나요?

단일 쿼리 방식의 논리
이 방법은 Bid와 AuctionResult 테이블을 조인하고, CASE 문을 사용하여 결과를 한 번에 가져오는 것입니다.
SELECT 절: Product 엔티티와 함께,
해당 상품의 낙찰자(AuctionResult.winner)가 현재 조회하는 Member와 같은지 확인하는 boolean 값을 선택합니다.
FROM 절: Bid 엔티티에서 시작해 Product와 AuctionResult 엔티티를 조인합니다.
WHERE 절: 현재 Member가 입찰한 상품들만 필터링합니다.
이러한 로직을 JPQL 쿼리로 구현하면 다음과 같은 형태가 됩니다.

SELECT p, CASE WHEN ar.winner = :member THEN true ELSE false END
FROM Bid b
JOIN b.product p
LEFT JOIN AuctionResult ar ON ar.product = p
WHERE b.bidder = :member
SELECT p: 입찰한 상품을 선택합니다.

CASE WHEN ar.winner = :member THEN true ELSE false END: AuctionResult의 winner가 현재 조회하는 member와 같으면 true를,
아니면 false를 반환합니다. 이것이 바로 낙찰 여부를 알려주는 플래그 역할을 합니다.
LEFT JOIN: 낙찰 결과(AuctionResult)가 없는 상품도 결과에 포함시키기 위해 LEFT JOIN을 사용합니다.
WHERE b.bidder = :member: 현재 멤버가 입찰한 기록만 필터링합니다.
이렇게 하면, 서비스 계층에서는 단 하나의 쿼리를 호출하고, 반환된 리스트를 받아서 바로 UI에 표시할 수 있습니다. 쿼리 자체가 모든 로직을 처리해주므로, 
별도의 반복문이나 추가적인 데이터베이스 호출이 필요 없습니다.